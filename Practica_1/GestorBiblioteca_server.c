/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "GestorBiblioteca.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

int num_administradores = 0; // Contador con el numero de administradores actualmente en el sistema
int IdAdmin = -1;			 // Copia del Identificador de Administración enviado al usuario.
TLibro *Biblioteca = NULL;	 // Vector dinámico de libros
int NumLibros = 0;			 // Número de libros almacenados en el vector dinámico.
int Tama = 0;				 // Tamaño del vector dinámico. El incremento será por bloques de 4 libros.
Cadena NomFichero = "";		 // Copia del nombre del último fichero binario que se ha cargado en memoria.
int CampoOrdenacion = 0;	 // Copia del último campo de ordenación realizado.

bool_t EsMenor(int P1, int P2, int Campo)
{
	bool_t salida = FALSE;
	TLibro L1 = Biblioteca[P1];
	TLibro L2 = Biblioteca[P2];

	switch (Campo)
	{
	case 0:
		salida = strcmp(L1.Isbn, L2.Isbn) < 0 ? TRUE : FALSE;
		break;
	case 1:
		salida = strcmp(L1.Titulo, L2.Titulo) < 0 ? TRUE : FALSE;
		break;
	case 2:
		salida = strcmp(L1.Autor, L2.Autor) < 0 ? TRUE : FALSE;
		break;
	case 3:
		salida = L1.Anio < L2.Anio ? TRUE : FALSE;
		break;
	case 4:
		salida = strcmp(L1.Pais, L2.Pais) < 0 ? TRUE : FALSE;
		break;
	case 5:
		salida = strcmp(L1.Idioma, L2.Idioma) < 0 ? TRUE : FALSE;
		break;
	case 6:
		salida = L1.NoLibros < L2.NoLibros ? TRUE : FALSE;
		break;
	case 7:
		salida = L1.NoPrestados < L2.NoPrestados ? TRUE : FALSE;
		break;
	case 8:
		salida = L1.NoListaEspera < L2.NoListaEspera ? TRUE : FALSE;
		break;
	}
	return salida;
}

void introduce_libro_en_vector(struct TLibro Libro)
{
	strcpy(Biblioteca[NumLibros].Isbn, Libro.Isbn);
	strcpy(Biblioteca[NumLibros].Titulo, Libro.Titulo);
	strcpy(Biblioteca[NumLibros].Autor, Libro.Autor);
	Biblioteca[NumLibros].Anio = Libro.Anio;
	strcpy(Biblioteca[NumLibros].Pais, Libro.Pais);
	strcpy(Biblioteca[NumLibros].Idioma, Libro.Idioma);
	Biblioteca[NumLibros].NoLibros = Libro.NoLibros;
	Biblioteca[NumLibros].NoPrestados = Libro.NoPrestados;
	Biblioteca[NumLibros].NoListaEspera = Libro.NoListaEspera;
}

int partition(TLibro *library, int low, int high, int sorting_field)
{
	int pivot = high;

	int i = (low - 1);

	for (int j = low; j <= high; j++)
	{
		if (EsMenor(j, pivot, sorting_field) == TRUE)
		{
			i++;
			TLibro aux = library[i];
			library[i] = library[j];
			library[j] = aux;
		}
	}

	TLibro aux = library[i + 1];
	library[i + 1] = library[high];
	library[high] = aux;

	return (i + 1);
}

void quick_sort(TLibro *library, int low, int high, int sorting_field)
{
	if (low < high)
	{
		int pi = partition(library, low, high, sorting_field);

		quick_sort(library, low, pi - 1, sorting_field);
		quick_sort(library, pi + 1, high, sorting_field);
	}
}

int *conexion_1_svc(char *argp, struct svc_req *rqstp)
{
	static int result;

	// Si ya tengo un administrador, devuelvo -1
	if (num_administradores == 1)
	{
		result = -1;
	}

	// Si aún no tengo ningún administrador y la contraseña es correcta, devuelvo un número aleatorio
	else if (strcmp(argp, "1234") == 0)
	{
		num_administradores++;
		result = 1 + rand() % RAND_MAX;
		IdAdmin = result;
	}

	// Si aún no tengo ningún administrador y la contraseña es incorrecta, devuelvo -2
	else
	{
		result = -2;
	}

	return &result;
}

bool_t *
desconexion_1_svc(int *argp, struct svc_req *rqstp)
{
	static bool_t result;

	if (IdAdmin == *argp)
	{
		IdAdmin = -1;
		num_administradores--;
		result = TRUE;
	}
	else
	{
		result = FALSE;
	}
	return &result;
}

int *cargardatos_1_svc(TConsulta *argp, struct svc_req *rqstp)
{
	static int result;
	FILE *fdatos = NULL;
	int num_lecturas = 0;

	// Si el id es correcto...
	if (argp->Ida == IdAdmin && argp->Ida > 0)
	{

		fdatos = fopen(argp->Datos, "rb");

		// Si se ha podido abrir el fichero...
		if (fdatos != NULL)
		{
			num_lecturas = fread(&NumLibros, sizeof(NumLibros), 1, fdatos);

			// Si se ha leido correctamente...
			if (num_lecturas == 1)
			{
				// Si ya existia el vector Biblioteca...
				if (Biblioteca != NULL)
				{
					free(Biblioteca);
					Biblioteca = (TLibro *)malloc(sizeof(TLibro) * NumLibros);
				}
				else
				{
					Biblioteca = (TLibro *)malloc(sizeof(TLibro) * NumLibros);
				}
				// Si se ha reservado memoria correctamente...
				if (Biblioteca != NULL)
				{
					num_lecturas = fread(Biblioteca, sizeof(TLibro), NumLibros, fdatos);

					// Si se ha leido correctamente...
					if (num_lecturas == NumLibros)
					{
						Tama = NumLibros;

						strcpy(NomFichero, argp->Datos);
						quick_sort(Biblioteca, 0, NumLibros - 1, CampoOrdenacion);

						result = 1;
					}
					else
					{

						result = 0;
					}
				}
				else
				{

					result = 0;
				}
			}
			else
			{

				result = 0;
			}
		}
		else
		{

			result = 0;
		}
	}
	else
	{

		result = -1;
	}
	if (fdatos != NULL)
	{
		fclose(fdatos);
	}

	return &result;
}

bool_t *
guardardatos_1_svc(int *argp, struct svc_req *rqstp)
{
	static bool_t result;
	FILE *fdatos = NULL;
	int num_escrituras = 0;

	if (Biblioteca != NULL)
	{
		// Si el id es correcto...
		if (*argp == IdAdmin && *argp > 0)
		{

			fdatos = fopen(NomFichero, "wb");

			// Si se ha podido abrir el fichero...
			if (fdatos != NULL)
			{

				num_escrituras = fwrite(&NumLibros, sizeof(NumLibros), 1, fdatos);

				// Si se ha escrito correctamente...
				if (num_escrituras == 1)
				{

					num_escrituras = fwrite(Biblioteca, sizeof(TLibro), NumLibros, fdatos);
					// Si se ha escrito correctamente...
					if (num_escrituras == NumLibros)
					{
						result = TRUE;
					}
					else
					{
						result = FALSE;
					}
				}
				else
				{
					result = FALSE;
				}
			}
			else
			{
				result = FALSE;
			}
		}
		else
		{
			result = FALSE;
		}
		if (fdatos != NULL)
		{
			fclose(fdatos);
		}
	}
	else
	{
		result = FALSE;
	}

	return &result;
}

int *nuevolibro_1_svc(TNuevo *argp, struct svc_req *rqstp)
{
	static int result;
	int i = 0;
	bool_t encontrado = FALSE;

	if (Biblioteca != NULL)
	{

		if (argp->Ida == IdAdmin && argp->Ida > 0)
		{
			// Busco si ya hay un libro en el vector con el mismo ISBN que el del libro pasado por parametro
			while (!encontrado && i < NumLibros)
			{
				if (strcmp(Biblioteca[i].Isbn, argp->Libro.Isbn) == 0)
				{
					encontrado = TRUE;
				}
				else
				{
					i++;
				}
			}
			if (encontrado == TRUE)
			{
				result = 0;
			}
			// No hay ya un libro con el mismo ISBN, luego introduzco el libro en el vector dinamico
			else
			{
				// Si el vector esta lleno, aumento su tamaño e introduzco el libro
				if (NumLibros == Tama)
				{

					TLibro *aux = (TLibro *)malloc(sizeof(TLibro) * (NumLibros + 4));

					if (aux != NULL)
					{
						for (int i = 0; i < NumLibros; i++)
						{
							aux[i] = Biblioteca[i];
						}
						free(Biblioteca);
						Biblioteca = aux;
						Tama = Tama + 4;
						introduce_libro_en_vector(argp->Libro);
						NumLibros++;
						quick_sort(Biblioteca, 0, NumLibros - 1, CampoOrdenacion);

						result = 1;
					}
					else
					{
						printf("Se ha producido un error en la reserva de memoria para agrandar el vector\n");
					}
				}
				// Si no esta lleno, introduzco el libro directamente
				else
				{
					introduce_libro_en_vector(argp->Libro);
					NumLibros++;
					quick_sort(Biblioteca, 0, NumLibros - 1, CampoOrdenacion);
					result = 1;
				}
			}
		}
		else
		{
			result = -1;
		}
	}
	else
	{
		result = -2;
	}

	return &result;
}

int *comprar_1_svc(TComRet *argp, struct svc_req *rqstp)
{
	static int result;
	bool_t encontrado = FALSE;
	int i = 0;

	if (Biblioteca != NULL)
	{

		if (argp->Ida == IdAdmin && argp->Ida > 0)
		{

			while (!encontrado && i < NumLibros)
			{
				if (strcmp(Biblioteca[i].Isbn, argp->Isbn) == 0)
				{
					encontrado = TRUE;
				}
				else
				{
					i++;
				}
			}
			if (encontrado == TRUE)
			{
				Biblioteca[i].NoLibros += argp->NoLibros;

				if (Biblioteca[i].NoLibros >= Biblioteca[i].NoListaEspera)
				{
					Biblioteca[i].NoLibros -= Biblioteca[i].NoListaEspera;
					Biblioteca[i].NoListaEspera = 0;
				}
				else if (Biblioteca[i].NoLibros < Biblioteca[i].NoListaEspera)
				{
					Biblioteca[i].NoListaEspera -= Biblioteca[i].NoLibros;
					Biblioteca[i].NoLibros = 0;
				}
				quick_sort(Biblioteca, 0, NumLibros - 1, CampoOrdenacion);
				result = 1;
			}
			else
			{

				result = 0;
			}
		}
		else
		{

			result = -1;
		}
	}
	else
	{
		result = -2;
	}

	return &result;
}

int *retirar_1_svc(TComRet *argp, struct svc_req *rqstp)
{
	static int result;
	bool_t encontrado = FALSE;
	int i = 0;

	if (Biblioteca != NULL)
	{

		if (argp->Ida == IdAdmin && argp->Ida > 0)
		{

			while (!encontrado && i < NumLibros)
			{
				if (strcmp(Biblioteca[i].Isbn, argp->Isbn) == 0)
				{
					encontrado = TRUE;
				}
				else
				{
					i++;
				}
			}
			if (encontrado == TRUE)
			{
				if (Biblioteca[i].NoLibros - argp->NoLibros >= 0)
				{
					Biblioteca[i].NoLibros -= argp->NoLibros;
					quick_sort(Biblioteca, 0, NumLibros - 1, CampoOrdenacion);
					result = 1;
				}
				else
				{
					printf("No hay suficientes ejemplares disponibles para ser retirados\n");
					result = 2;
				}
			}
			else
			{
				printf("No se ha encontrado el libro en la biblioteca\n");
				result = 0;
			}
		}
		else
		{
			printf("El id de admin es incorrecto\n");
			result = -1;
		}
	}
	else
	{
		result = -2;
	}

	return &result;
}

bool_t *
ordenar_1_svc(TOrdenacion *argp, struct svc_req *rqstp)
{
	static bool_t result;

	if (argp->Ida == IdAdmin && argp->Ida > 0 && Biblioteca != NULL)
	{
		quick_sort(Biblioteca, 0, NumLibros - 1, argp->Campo);
		CampoOrdenacion = argp->Campo;
		result = TRUE;
	}
	else
	{
		result = FALSE;
	}

	return &result;
}

int *nlibros_1_svc(int *argp, struct svc_req *rqstp)
{
	static int result = -1;

	if (Biblioteca != NULL)
	{
		result = NumLibros;
	}

	return &result;
}

int *buscar_1_svc(TConsulta *argp, struct svc_req *rqstp)
{
	static int result;
	int i = 0;
	bool_t encontrado = FALSE;

	if (Biblioteca != NULL)
	{
		if (argp->Ida == IdAdmin && argp->Ida > 0)
		{

			while (!encontrado && i < NumLibros)
			{
				if (strcmp(Biblioteca[i].Isbn, argp->Datos) == 0)
				{
					encontrado = TRUE;
				}
				else
				{
					i++;
				}
			}

			if (encontrado == TRUE)
			{
				result = i;
			}
			else
			{
				result = -1;
			}
		}
		else
		{
			result = -2;
		}
	}
	else
	{
		result = -3;
	}

	return &result;
}

TLibro *
descargar_1_svc(TPosicion *argp, struct svc_req *rqstp)
{
	static TLibro result;

	if (argp->Ida == IdAdmin && argp->Ida > 0)
	{
		// Si la posicion es incorrecta o la Biblioteca es nula
		if (argp->Pos >= NumLibros || argp->Pos < 0 || Biblioteca == NULL)
		{
			strcpy(result.Isbn, "????");
			strcpy(result.Titulo, "????");
			strcpy(result.Autor, "????");
			strcpy(result.Idioma, "????");
			strcpy(result.Pais, "????");
			result.Anio = 0;
			result.NoLibros = 0;
			result.NoListaEspera = 0;
			result.NoPrestados = 0;
		}
		// Si es correcta y la Biblioteca no es nula
		else
		{
			result = Biblioteca[argp->Pos];
		}
	}
	// Si el ida es incorrecto
	else
	{
		result = Biblioteca[argp->Pos];
		result.NoListaEspera = 0;
		result.NoPrestados = 0;
	}

	return &result;
}

int *prestar_1_svc(TPosicion *argp, struct svc_req *rqstp)
{
	static int result;

	// Si la posicion es incorrecta o la Biblioteca es nula
	if (argp->Pos >= NumLibros || argp->Pos < 0 || Biblioteca == NULL)
	{
		result = -1;
	}
	// Si es correcta y la Biblioteca no es nula
	else
	{
		// Si hay ejemplares disponibles
		if (Biblioteca[argp->Pos].NoLibros > 0)
		{
			Biblioteca[argp->Pos].NoLibros--;
			Biblioteca[argp->Pos].NoPrestados++;
			result = 1;
		}
		// Si no hay ejemplares disponibles
		else
		{
			Biblioteca[argp->Pos].NoListaEspera++;
			result = 0;
		}
		quick_sort(Biblioteca, 0, NumLibros - 1, CampoOrdenacion);
	}

	return &result;
}

int *devolver_1_svc(TPosicion *argp, struct svc_req *rqstp)
{
	static int result;

	// Si la posicion es incorrecta o la Biblioteca es nula
	if (argp->Pos >= NumLibros || argp->Pos < 0 || Biblioteca == NULL)
	{
		result = -1;
	}
	// Si es correcta y la Biblioteca no es nula
	else
	{
		// Si hay usuarios en espera
		if (Biblioteca[argp->Pos].NoListaEspera > 0)
		{
			Biblioteca[argp->Pos].NoListaEspera--;
			result = 0;
		}
		// Si no hay usuarios en espera pero si libros prestados
		else if (Biblioteca[argp->Pos].NoListaEspera == 0 && Biblioteca[argp->Pos].NoPrestados > 0)
		{
			Biblioteca[argp->Pos].NoPrestados--;
			Biblioteca[argp->Pos].NoLibros++;
			result = 1;
		}
		// Si ni hay usuarios en lista de espera ni hay libros prestados
		else if (Biblioteca[argp->Pos].NoListaEspera == 0 && Biblioteca[argp->Pos].NoPrestados == 0)
		{
			result = 2;
		}
		quick_sort(Biblioteca, 0, NumLibros - 1, CampoOrdenacion);
	}

	return &result;
}
